---
title: 【学习】许世伟的架构课（极客时间）（二）
tags:
  - 学习
  - 软件
categories:
  - 软件工程
toc: false
date: 2020-09-23 15:47:09
---

以前的同系列文章：[许世伟的架构课（一）](https://wushuangabao.github.io/hexo/2019/06/17/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AE%B8%E4%B8%96%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/)

<!--more-->

## 11多任务：进程、线程、协程

### 实现多任务

物理层面的多任务，有两个方法：一个是多颗 CPU，一个是单颗 CPU 多个核心。

在桌面端，大多数情况用的是后者，因为桌面端的产品（个人计算机、手机、手表等）还是很在意产品的体积如何尽可能做得更小；
而服务器领域，通常同时使用两者，它更多关注的是如何尽可能提升单台计算机的计算力密度。

如果我们实际就只有**一个单核的 CPU** 呢？

把 CPU 的时间切成一段段**时间片**，每个时间片只运行某一个软件。这个时间片给软件 A，下一个时间片给软件 B。因为时间片很小，我们会感觉这些软件同时都在运行。这种分时间片实现的多任务系统，我们把它叫**分时系统**。

原理：把当前任务状态先保存起来，把另一个任务的状态恢复，并把执行权交给它。

这里面涉及的问题有：
- 任务是什么，怎么抽象任务这样一个概念；
- 任务的状态都有什么？怎么保存与恢复；
- 什么时机会发生任务切换？

### 执行体

**任务的抽象（“执行体”）**并不是唯一的。大部分操作系统提供了两套：进程和线程。有的操作系统还会提供第三套叫协程（也叫纤程）。

执行体，是指**可被 CPU 赋予执行权的对象**，它至少包含下一个**执行位置**（获得执行权后会从这里开始执行）以及其他的**运行状态**。

任务的状态（执行体的上下文）包括：
- 寄存器，通过名字来存取；
- 内存（RAM），实模式下多个执行体之间无干扰，保护模式下通过**切换地址映射表**来切换状态，而切换地址映射表也通过寄存器。

总结：执行体的上下文，就是一堆寄存器的值。要切换执行体，只需要保存和恢复一堆寄存器的值即可。

### 进程与线程

|执行体|地址空间|调度方|时间片调度|主动调度|
|-|-|-|-|-|
|进程|不同执行体有不同地址空间|操作系统内核|基于时钟中断|系统调用（syscall）|
|线程|不同执行体共享地址空间|操作系统内核|基于时钟中断|系统调用（syscall）|
|协程|不同执行体共享地址空间|用户态|一般不支持|包装系统调用|

进程是操作系统从安全角度来说的隔离单位，不同进程之间基于最低授权的原则。

线程的出现，则是因为操作系统发现同一个软件内还是会有多任务的需求，这些任务处在相同的地址空间，彼此之间相互可以信任。

### 协程与goroutine

#### 解决的需求

协程是在用户态下实现的，它的出现是**实现高性能的网络服务器**的需要。

- 对网络服务器来说，大量的来自客户端的请求包和服务器的返回包，都是网络 IO；
- 在响应请求的过程中，往往需要访问存储来保存和读取自身的状态，这也涉及本地或网络 IO。

为了改进网络服务器的吞吐能力，主流的做法是用 epoll（Linux）或 IOCP（Windows）机制。这两个机制颇为类似，都是在需要 IO 时登记一个 IO 请求，然后统一在某个线程查询谁的 IO 先完成了，谁先完成了就让谁处理（[epoll机制参考](https://blog.csdn.net/weixin_34015336/article/details/85124052?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)）。从系统调用次数的角度，epoll 或 IOCP 都是产生了更多次数的系统调用。从内存拷贝来说也没有减少。所以使用它们真正有意义的事情是：减少了线程的数量。

这样网络服务器就只能用异步 IO 来写程序。它让程序逻辑碎片化，很反人类。

> 知名的异步 IO 网络库 libevent 就是对 epoll 和 IOCP 这些机制包装了一套跨平台的异步 IO 编程模型。
> Node.js 一炮而红，也是因为把 JavaScript 的低门槛和 libevent 的高性能结合起来，给了前端程序员一个“我也能搞高性能服务器”的梦想。

为什么希望减少线程数量？
- 空间成本是第一根稻草。默认情况下 Linux 线程在数 MB 左右，其中最大的成本是堆栈；
- 执行体的调度开销，以及执行体之间的同步与互斥成本，也是不可忽略的（时间）成本。

综上，协程的目的是：
- 回归到同步 IO 的编程模式；
- 降低执行体的空间的空间成本和时间成本。

#### 如何解决？

大部分协程库，连协程的基础功能也是半吊子的。这里面最难搞的是堆栈。

协程的堆栈如果太小则可能不够用；如果太大则空间成本过高，影响能够处理的网络请求的并发数。理想情况下，堆栈大小需要能够自动适应需要。

一个完备的协程库可以理解为用户态的操作系统。

完备的协程库：Erlang 和 Go 语言。

Go 语言里的 goroutine 有这样一些重要设计：
- 堆栈开始很小（只有 4K），但可按需自动增长；
- 坚决干掉了 “线程局部存储（TLS）” 特性的支持，让执行体更加精简；
- 提供了同步、互斥和其他常规执行体间的通讯手段，提供了几乎所有重要的系统调用（尤其是 IO 请求）的包装。

### 架构师的批判性思维

执行体的设计，有非常多值得反思的地方。

操作系统内核之中，不乏无数精妙的设计思想。但是，前辈们也并非圣贤，也可能会出现一些决策上失误，留下了诸多后遗症。

作为后辈的我们，在体会这些精妙的设计思想的同时，也要批判性去吸收。

## 12进程内协同：同步、互斥与通信



## 13进程间的同步互斥、资源共享与通讯