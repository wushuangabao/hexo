---
title: 《C++语言的设计与演化》
tags:
  - C/C++
  - 阅读
categories:
  - 编程艺术
  - 书中所得
toc: false
date: 2021-01-27 09:50:26
---

这是一本很老的书了（2001年出版），如今C++已经有了很多新的发展。但是这本书是C++语言之父亲手写的，讲述了C++的发展演化史、设计理念，对于大多数人来还是很有阅读价值。

<!--more-->

## 译者序

注：译者为裘宗燕

从来都没有一种完美的程序设计语言。C++语言由于其出身(C语言)，由于其发展过程中各种历史和现实因素的影响，也带着许多瑕疵和不和谐，尤其是在作为C++基础的C语言的低级成分与面向数据抽象的高级机制之间。……**为了系统的效率和资源的有效利用，人们希望有更直接的控制手段(低级机制)；而为了将复杂的功能组织成人能够理解和把握的系统，又需要有高级的机制和结构。**在使用一个同时提供了这两方面机制的语言时，应该如何合理而有效地利用它们，使之能互为补充而不是互相冲突，本书中许多地方讨论到这些问题，也提出了许多建议。

……作为译者，我希望作为自己工作结果的这个中译本能给学习C++语言、用这个语言从事教学、从事程序设计工作和复杂系统程序设计的人们提供一点帮助，使这本有关C++语言的**最重要著作**中阐述的事实和思想能够被更多人所了解。

## 目录

仅列出我觉得有用的部分。

### 第一部分

- 第1章 C++的史前时代
	- Simula和分布式系统
	- C与系统程序设计
	- 一般性的背景
- 第2章 带类的C
	- 特征概览
	- 类
	- 运行时的效率
	- 连接模型
		- 淳朴的实现
		- 对象布局模型
	- 静态类型检查
		- 窄转换
		- 警告的使用
	- 为什么用C
	- 语法问题
	- 派生类
		- 没有虚函数时的多态性
		- 没有模板时的容器类
		- 对象布局模型
	- 保护模型
	- 运行时的保证
		- 构建函数与析构函数
		- 存储分配和建构函数
		- 调用函数和返回函数
	- 次要特征
	- 考虑过，但没有提供的特征
	- 工作环境
- 第3章 C++的诞生
	- 目标
	- Cfront
	- 语言特征
	- 虚函数
		- 对象布局模型
		- 覆盖和虚函数匹配
		- 基成员的遮蔽
	- 重载
		- 基本重载
		- 成员和友元
		- 运算符函数
		- 效率和重载
		- 变化和新运算符
	- 引用
	- 常量
	- 存储管理
	- 类型检查
	- 次要特征
	- 与经典C的关系
	- 语言设计的工具
- 第6章 标准化
	- 什么是标准
	- 委员会如何运作
	- 净化
		- 查找问题
		- 临时量的生存期
	- 扩充
	- 扩充建议实例
		- 关键词参数
		- 受限指针
		- 字符集
- 第7章 关注和使用
	- 商业竞争
- 第8章 库
- 第9章 展望
	- 回顾
		- C++是不是一个统一的语言
		- 什么是最大失误
	- 仅仅是一座桥梁吗

### 第二部分

- 第10章 存储管理
	- 将存储分配和初始化分离
	- 数组分配
	- 放置
	- 存储释放问题
	- 存储器耗尽
	- 自动废料收集
- 第11章 重载
	- 重载的解析
		- 细粒度解析
		- 歧义控制
		- 空指针
		- overload 关键字
	- 类型安全的连接
	- 对象的建立和复制
	- 记法约定
		- 指针
		- 引用
		- 增量和减量的重载
		- 重载->*
		- 重载逗号运算符
	- 给C++增加运算符
		- 指数运算符
		- 用户定义运算符
		- 复合运算符
	- 枚举
		- 关于枚举的重载
		- 布尔类型
- 第12章 多重继承
	- 普通基类
	- 虚基类
	- 对象布局模型
		- 虚基布局
		- 虚基和强制
	- 方法组合
	- 委托
	- 重命名
	- 基和成员初始式
- 第13章 类概念的精炼
	- 抽象类
	- const成员函数
		- 强制去掉const
		- const定义的精炼
		- 易变性与强制
	- 静态成员函数
	- 嵌套的类
	- Inherited::
	- 放松覆盖规则
	- 多重方法
	- 保护成员
	- 改进代码生成
	- 到成员的指针
- 第14章 强制
	- 运行时类型信息
		- dynamic_cast运算符
		- RTTI的使用和误用
		- 为什么提供一个“危险特征”
		- typeid()运算符
		- 对象布局模型
		- 考虑过的其他选择
	- 强制的一种新记法
		- static_cast运算符
		- reinterpret_cast运算符
		- const_cast运算符
		- 新风格强制的影响
- 第15章 模板
	- 模板的实例化
		- 显式的实例化
		- 实例化点
		- 专门化
		- 查找模板定义
	- 模板的作用
- 第16章 异常处理
- 第17章 名字空间

## 设计理念/哲学

（摘自《1.3 一般性的背景》）

我发现了齐克果对个人的几乎狂热的关心以及敏锐的心理洞察力，这比黑格尔和马克思的抽象的宏伟蓝图和对人性的关心更具感染力。尊重人群而不尊重人群中的个体实际上就是什么也不尊重。**C++的许多设计决策根源于我对强迫人按某种特定方式行事的极度厌恶**。在历史上，一些最坏的灾难就起因于理想主义者们试图强迫人们“做某些对他们最好的事情”。这种理想主义不仅导致了对无辜受害者的伤害，也迷惑和腐化了施展权利的理想主义者们。我还发现，对于与其教义或理论出现不寻常的冲突的经验和实验，理想主义者往往有忽略它们的倾向。在理想出现问题的地方，甚至当空谈家也要赞成的时候，我宁愿提供一些支持，**给程序员以选择的权利**。

对文学的热爱更增强了我的认识：仅根据理论和逻辑做决策是没有希望的。在这个意义上说，C++由小说家和散文家那里得到的东西也很多，例如马丁·汉森、阿尔伯特·加缪以及乔治·奥维尔等。他们根本没有见过计算机，但对于C++的贡献却与计算机科学家如David Gries，Don Knuth，Roger Needham一样大。经常地，如果我试图去取缔一个我个人不喜欢的语言特征时，我总抑制住自己这样做的欲望，因为我不认为自己有权把个人观点强加给别人。我知道通过强力地推行逻辑，毫无同情心地谴责“思想中坏的、过时的、混乱的习惯”，是可能在相对短的时间里有更多的建树。但是，**人的代价总是最高的**。不同的人们确实会按不同的方式思考，喜欢按不同的方式做事情，对于这些情况的高度容忍和接受是我最愿意的事情。

我的希望是慢慢地——经常是令人痛苦的慢——推动人们去试验新的技术，接受那些适合他们需要或者是口味的东西。确实存在着更有效的技术去达到“宗教信仰转变”或者“革命”，但是我极端厌恶这类技术，从根本上怀疑它们在长时期和大范围上的作用。……

我愿意努力工作，采纳那些我确信能够对人有所帮助的想法。事实上，我认为，科学家和知识分子的责任就是保证他们的思想可以被公众接受，从而对社会有用，而不是为了做出一些专家们的玩物。当然，我并不想让人作为思想的牺牲品。特别地，我绝不想通过一种有局限性的程序设计语言定义去推行某种惟一的设计理念。人们思维的方式是如此的丰富多彩，企图推行一种单一理念总是弊多于利。这样，C++被有意地设计成能够支持各种各样的风格，而不是强调“一条真理之路”。

## “带类的C”

### 语法问题

#### 2.8.1 C声明的语法

在C语言的语法中，我最不喜欢的就是声明的语法。同时带有前缀和后缀的声明描述符带来了太多的混乱。例如:
```
int*p[10]; /* array of 10 pointers to int, or */
           /* pointer to array of 10 ints?    */
```

允许省略类型描述符（默认是int)也带来了许多复杂性,例如:
```
          /* C style (proposed banned):   */
static a; /* implicit: type of 'a' is int */
f();      /* implicit: returns int        */

          // proposed C with Classes style:
static int a;
int f();
```
要是在这个领域中作修改，用户的否定性反应是非常强烈的。他们把作为C精神的“简练性”推进到如此地步，以至于拒绝使用要求他们写多余的类型描述符的任何一种“法西斯”语言。我从这种修改退了回来，因为没有其他选择。允许隐含的int今天仍然是C++语法中许多最恼人的问题的根源。请注意，这个压力是来自用户，而不是来自管理者或者坐在扶手椅上的语言专家。十年后C++的ANSI/ISO标准化委员会（第6章）决定反对隐含的int。这意味着我们还需要十年左右才有可能摆脱这种东西。

在带类的C和C++里采用了在函数括号里写参数类型的函数定义语法，这种方式后来也被ANSI C所采纳:
```
f(a, b) char b; /* K&R C sty1e function definition */
{
    /* ... */
}

int f(int a, char b) //C++ style function definition
{
    // ...
}
```

与此类似，我还考虑了引进线性形式的声明的可能性。C所采用的诡计就是让名字的**声明**去模仿它们的**使用**，这就使声明既难读又难写，使人和程序都很容易把声明和表达式弄混。许多人都发现，C语言声明的问题在于声明符*(“指针”)是前缀，而[](“数组”)和()(“返回函数”）是后缀。这就迫使人们在出现歧义时必须使用括号，例如:
```
               /* C style:                  */
int* v[10];    /* array of pointers to ints */
int (*p)[10];  /* pointer to array of ints  */
```

与Doug Mcllroy，Andrew Koenig，Jonathan Shopiro以及其他人一起，我们考虑引进后缀的“指针”声明符->作为前缀声明符*的替代品:
```
               // radical alternative :
v: [10]->int;  // array of pointers to ints
p: ->[10]int;  // pointer to array of ints

               // less radica1 alternative :
int v[10]->;   // array of pointers to ints
int p->[10];   //pointer to array of ints
```

这种不那么激烈的改变有很大的优点，它允许后缀的->声明符与前缀的*声明符在转变期间同时存在，在这个转变期结束之后，就可以把*声明符和多余的括号从语言里去掉。这种方式的一个显著好处是使括号只用于描述“函数”，这样，造成混乱的机会和语法上的微细差别都被去除了。把所有声明符都变成后缀形式，还能保证声明可以从左向右读，例如:
```
int f(char)->[10]->(double)->;
```
这意味着函数f返回一个指针，该指针指向数组，这是指针的数组，其指针指向返回int指针的函数。请试试写这种直线式的C/C++。不幸的是我把这个想法漏掉了，甚至没有发布过一个实现。与此对应的是人们用typedef逐步构造起复杂的类型:
```
typedef int* DtoI(double); // function taking a double and
                           // returning a pointer to int
typedef DtoI v10[10];      // array of 10 pointers to DtoI
v10* f(char);              // f takes a char and returns
                           // a pointer to v10
```

我最后还是理智地让事情保持其原来的模样，因为任何新语法将进一步（至少是临时性地）增加一个已知为烂泥潭的东西的复杂性。还有，老风格的东西对于喜欢唠叨琐碎事情的教师，或者喜欢嘲弄C的人都是最好的赏赐，对C程序员而言这也不是什么重要问题。在这种情况下我不清楚是否真的做了正确的事。语法的乖僻给我和其他C++实现者、写文档的人以及工具的构造者们带来的苦恼是非常明显的。用户当然可以让自己摆脱这类问题，方式就是只使用C/C++声明的一个小而清楚的子集（ 7.2节)，他们也确实这样做了。

#### 2.8.2 结构标志与类型名

C++引进了一个能给用户带来益处的重要的语法简化，代价是实现语言的人们要多做些工作，还有与C的一些不兼容问题。在C语言里，在结构的名字（结构标志）之前必须出现关键字struct，例如:
```
struct buffer a; /* struct is necessary in C */
```

在带类的C里，这件事让我苦恼了很久，因为这就使得用户定义类型在语法上变成了二等公民。由于我清理语法的其他企图都没有成功，在这里也就犹豫了。后来在Tom Cargill的鼓励下才做了修改——在带类的C向C++演化的时候。在C++里，`struct`，`union`和`class`的名字本身就是类型名，不再需要特定的语法标识符:
```
buffer a;  // C++
```

由此造成的与C兼容性的斗争持续了很多年（也参见3.12节)。例如，下面这样的东西在C里是合法的:
```
struct S { int a; };
int S;
void f(struct S x)
{
    x.a = S; // S is an int variable
}
```

它在带类的C和C++里也是合法的。然而在这许多年里我们一直努力想找到一种方式，使它能允许上面这种（几近怪诞，然而也无害的）东西出现在C++里，只是为了兼容性。允许这种例子就意味着必须拒绝:
```
void g(S x)  // error: S is an int variablex
{
    x.a = S; // S is an int variable
}
```

处理这类特殊问题的实际需求来自这样的事实：某些标准UNIX头文件，特别是stat.h，就依赖于让struct与某个变量或者函数取同样的名字。这类兼容性问题对于那些语言律师们是重要的，这也正是他们的爱好。不幸的是，在找到一个令人满意——通常又是极端简单——的解决方案之前，这类问题将消耗掉我们无穷无尽的时间和精力。一旦找到了一个解决方案，一个兼容性问题就会变得极端无聊，因为它没有任何内在的智力价值，所具有的不过是实践中的某些重要性。
C++对于C多名字空间的解决办法是：一个名字可以指称一个类，同时也可以指称一个函数或者一个变量。如果某个名字真的同时指称这两种不同的东西，那么这个名字本身指称的就是那个非类的东西，**除非**在前面明显地加上关键字`struct`，`union`或者`class`。
因为需要对付倔强的守旧的C语言用户和所谓的C专家，纯正的C/C++兼容性问题是C++开发过程中最困难的也是最受挫折的领域。现在也依然是如此。

