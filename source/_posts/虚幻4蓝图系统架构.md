---
title: 虚幻4蓝图系统架构
tags:
  - C/C++
  - 学习
  - UE4
categories:
  - 游戏引擎
toc: false
date: 2021-04-01 16:01:55
---

本文是对《大象无形：虚幻引擎》第13章《蓝图》的记录。

<!--more-->

## 蓝图架构简述

蓝图是虚幻引擎提供的面向对象的可视化编程系统。小型蓝图的编译速度远远快过C++的编译速度，而且UE在发布最终版本的时候会将蓝图编译为C++从而提升其执行效率，因此选择C++的理由可能只剩下C++本身更大范围的API，以及蓝图系统在内容较多时不如C++直观的原因。

蓝图系统是一套依托于UE现有UClass、UProperty、UFunction框架，根植于Unreal Script字节码编译器系统的一套可视化编程系统。蓝图最终编译结果依然会转化为UClass、UProperty、UFunction信息。其中指令代码将会存储于UFunction的信息中。

蓝图系统实际上是由三个部分组成的：
- 蓝图编辑系统
- 蓝图本身
- 蓝图编译后的字节码

最终编译完成的**蓝图字节码**将不会包含**蓝图本身的节点信息**。这部分信息是在`UEdGraph`数据结构中存储的，这也是一种优化。

## 前端：蓝图存储与编辑

`UEdGraph`有三个重要数据：
```
class UEdGraph : public UObject
{
public:
	/** The schema that this graph obeys */
	TSubclassOf<class UEdGraphSchema>  Schema;

	/** Set of all nodes in this graph */
	TArray<class UEdGraphNode*> Nodes;

	/** Child graphs that are a part of this graph; the separation is purely visual */
	TArray<class UEdGraph*> SubGraphs;
```

### Schema

Schema的意思是语法，它规定当前蓝图能够产生什么样的节点等信息。当定义了自己的Schema之后，通过重载对应的函数即可实现语法的规定。常用的重载函数有：
- `GetContextMenuActions`定义当前蓝图编辑器中右键菜单的菜单项。通过向`FGraphContextMenuBuilder`中填充内容可以定制右键菜单。
- Drop系列函数，从外部拖放一个资源对象进入蓝图时触发。包括拖放到蓝图中、节点上和Pin上。

### 编辑器

蓝图的编辑器实质上是一个Slate控件，即`SGraphEditor`。可以这样理解，`UEdGraph`存储蓝图的“数据”资料，`SGraphEditor`通过解析数据生成对应的“显示控件”并处理交互。类似于MVC架构中的View部分。

在`SNew`实例化`SGraphEditor`的时候，传入一个`UEdGraph*`类型的参数`GraphToEdit`，即可指定当前编辑器正在编辑的蓝图。

## 后端：蓝图的编译

> 只有**包含具体逻辑**的蓝图才**需要编译**为蓝图字节码，有一些蓝图仅仅只需要自身数据就可以了。

蓝图`UBlueprint`编译完成产生的结果，应当是一个包含完整信息的`UClass`对象，而不是对应的类的对象。

> UClass继承自UStruct。UStruct只包含成员变量的反射信息，支持高速的构造和析构；而UClass则更加重量级，需要对成员函数进行反射。
> 在UClass中有成员变量`FuncMap`，用于存储当前UClass包含的成员函数信息。同一个类的所有对象共有同样的成员函数，因此成员函数的信息存储于**类数据**中，而非存储在每个对象中。

### 编译过程

一个蓝图会经历以下过程，最终产生出UClass：
1. 类型清空，清空当前类的内容。每个蓝图生成的类，即`UBlueprintGeneratedClass`，都会被复用（并非被删除后创建新的实例）。对应函数为`CleanAndSanitizeClass`。
2. 创建类成员变量。根据蓝图中的`NewVariables`数组与其他位置定义的类成员变量，创建`UProperties`。对应的函数为`CreateClassVariablesFromBlueprint`。
3. 处理事件蓝图。调用`CreateAndProcessUberGraph`函数，将所有的事件蓝图复制到一张超大蓝图里面，此时每个节点都有机会去展开自己（例如宏节点）。同时每个事件蓝图都会创建一个`FKismetFunctionContext`对象与之对应。
4. 处理函数蓝图。普通的函数蓝图通过`ProcessOneFunctionGraph`函数进行处理。此时每个函数蓝图会被复制到一个暂时的蓝图里面，同时节点有机会被展开。同样，每个函数蓝图都会有一个`FKismetFunctionContext`与之对应。
5. 预编译函数。`PrecompileFunction`函数对函数进行预编译。其完成了这样的内容：
	1. “修剪”蓝图，只有连接的节点才会被保留，无用的节点会被删掉；
	2. 运行现在还剩下的节点句柄的`RegisterNets`函数。
	3. 填充函数的骨架，包括参数和局部变量的信息。但是里面还没有脚本代码。
6. 组合和链接类。此时编译器已经获得了当前类的所有属性与函数的信息，可以开始组合和链接类了。包括填充变量链表、填充变量的大小、填充函数表等。这一步本质上产生了一个类的头文件以及一个类默认对象（CDO），但是缺少类的最终标记以及元数据。
7. 编译函数。这一步还没产生实际的虚拟机码。包括以下步骤：
	1. 调用每个节点句柄的Compile函数，从而生成一个`FKismetCompiledStatement`对象。
	2. 调用`AppendStatementForNode`函数。
8. 完成类编译。填充类的标记和元数据，并从父类中继承需要的标记和元数据。进行一系列的最终检测，确保类被正确编译。
9. 后端产生最终代码。后端逐函数地转换节点状态集合为最终代码。如果使用`FKismetCompilerVMBackend`，则产生虚拟机字节码，使用`FKismetCppBackend`则产生C++代码。
10. 复制类默认值对象属性。借助一个特殊函数`CopyPropertiesForUnrelatedObjects`将老的类默认对象的值复制到新的对象中。因为这个转换是通过基于Tag的序列化完成的，因此只要名字没变，值就会被转换过来。而组件则会被重新实例化，并被适当地修复。
11. 重新实例化。由于新的类的大小可能会改变，参数也有可能增减，编译器需要对原来的那个类的所有对象进行重新实例化。首先借助`TObjectInterator`来找到正在编译的类的所有实例，生成一个新的类，然后通过`CopyPropertiesForUnrelatedObjects`将老实例的值更新到新的实例。

在这个过程中涉及的术语如下:
- `FKismetCompilerContext` 完成实际编译工作的类。每次编译都会创建一个新的对象。这个类存储了正在被编译的蓝图和类的引用。
- `FKismetFunctionContext` 包含编译一个单独函数的信息，持有对应蓝图（不一定是函数蓝图）的引用、属性的引用以及生成的UFunction的引用。
- `FNodeHandlingFunctor` 单例类，也是辅助类。用于处理编译过程中的一类节点的类。包含一系列的函数，用于注册连接线以及生成编译后的Statement信息。
- `FKismetCompiledStatement` 一个编译器的独立工作单元。编译器把节点转换为一系列已经编译好的表达式，最终后端会将表达式转换为字节操作码。案例：变量赋值、Goto、Call。
- `FKismetTerm` 蓝图中的一个端子（literal、const或者vaiable的引用）。每个数据链接点都对应一个这个东西。你可以在`NodeHandlingFunctor`中创建你自己的端子，用来捕获变量或者传递结果。

### 多编译器适配

对于每一个对当前蓝图进行编译的请求（通过调用`FKismet2CompilerModule::CompileBlueprint`函数），会询问当前所有的Compiler，调用它们的`CanCompile`函数，询问是否可以编译当前蓝图。

如果某个类实现了`IKismetCompilerInterface`接口，那么就可以通过以下代码来在Kismet编译器中注册Compiler。虚幻引擎自己的系统UMG编辑器就是通过这样的方式注册自己为一个编译器的。
```
IKismetCompilerInterface& KismetCompilerModule = FModuleManager::LoadModuleChecked<IKismetCompilerInterface>("KismetCompiler ");
KismetCompilerModule.GetCompilers().Add(this);
```

### 编译上下文
### 整理与归并
### 节点处理
### 后话：VM虚拟机调用
### 小结

## 蓝图虚拟机

### 便笺纸与白领的故事

### 虚幻引擎的实现

### C++函数注册到蓝图

## 蓝图系统小结