---
title: 限制与抽象：找到不变量的方法
tags:
  - 软件
  - 方法
originContent: ''
categories:
  - 扯淡杂文
toc: false
date: 2019-08-31 22:17:19
---

## 思想实验：发明万能机器

**能否发明一台可以解决一切问题的机器？**

“解决一切问题”，这似乎是异想天开，因为它实在太大，大到不着边际。这里的问题包罗万象、变化万千，以至于让人完全不知道从何入手。

如果我们人为加上一些“限制”，问题就会变得可解（其实就是更容易被人理解）。因此，我们不妨在头脑中做一些假设。

**假设**我们有一台机器，它有极强的“计算”能力。然后把“一切问题”**限制**为“一切可计算的问题”。

由此，我们很容易会想到去思考“计算”本身。

所谓计算，其实就是将一个数据（输入x）变换为另一个数据（输出y）。在数学中，我们用“函数”来表示：y = F(x)

无论数据 x、y 的含义是什么，它们的本质都是信息（它们都可以**抽象**成信息）。而信息可以用 bit 量化为数字（根据信息论），物理上可以用一段连续的字节内容来表达。所以，我们需要有一个物理“存储”用来存放操作的数据。

解决了 x、y，接下来的问题是“函数 F”也是未知的。

**假设**，我们只掌握最小化的计算单元，比如“加减乘除”。怎样用这些计算单元，表达任意复杂度的函数（计算）？

估计多数人首先想到的是泰勒展开式——如果函数足够光滑的话，可以用某一点（x = a）的各阶导数值做系数，构建一个多项式来近似函数在这一点的邻域中的值。
这样确实可以用来表达某些函数（比如正弦函数），但还远远不够。

再加上一些限制。函数的计算具有各种各样的复杂流程，我们把这些流程**限制**成 3 种：顺序、分支、循环。
通过这个限制，大大降低了函数的表达难度，但是并没有降低复杂性。因为 3 种流程的排列组合，仍然可以实现无数种算法——就像 DNA 只有 4 种碱基一样。

为了便于理解，我们还需要**抽象**——把“一系列流程的组合”封装成一个“黑盒子”，我们忽略它的内部细节，只关注它的输入、输出。

好，这样我们就可以用一组指令的序列来表达函数了。这些指令包括：
* 执行最小计算单元（也就是内置函数）；
* 执行顺序，包括条件分支、循环；
* 执行其他自定义的函数（子函数）。

我们把这样的指令序列叫做“程序”，它是计算的载体。程序也是信息，它也存放在“存储”中。

于是，我们给负责计算的机器加上物理存储。看上去，它已经可以进行任意复杂的“计算”了。但是它还无法和现实世界发生交互，即输入和输出。

除了要有能够把现实世界的信号**抽象**成数据的设备，还要**限制**各个设备之间交换数据的方式，即定义好统一的数据交换契约。

**至此，经由多次的限制与抽象，我们得到了简化的冯·诺依曼机**。它是所有现代计算机的原型。