---
title: 《游戏编程模式》读书笔记
tags:
  - 阅读
  - 设计模式
categories:
  - 书中所得
  - 编程艺术
toc: false
date: 2020-09-02 10:15:05
---

《游戏编程模式》

Robert Nystrom 尼斯卓姆

部分微信读书笔记，摘录如下：

<!--more-->

## 第1篇 概述

> 你必须要考虑**程序的哪一部分应该要解耦**然后**在这些地方引入抽象**。同样地，你要确定**在哪里做一些扩展**以便将来很容易应对变化。
> 人们对此非常兴奋。他们设想着，未来的开发者（或者是他们自己）进入代码库，发现代码库开放、强大，只等着被加些扩展。他们想象一个游戏引擎便可统治一切。
> 但是，事情就在这里开始变得棘手。当你添加了一个抽象层或者支持可扩展的地方，你**猜想**到你以后会需要这种**灵活性**，于是你便为你的游戏**增加**了代码和**复杂性**，这需要时间来开发、调试和维护。
> 如果你猜对了，那么你之前的辛苦就没白费，而且也无须再对代码进行任何修改。但是**猜测未来是很难的**，并且当模块最终没起到作用时，很快它就变得有害。毕竟，你必须处理这些多出来的代码。

**解耦**意味着在你进行扩展时仅需理解少量代码，然而**抽象**却增加了理解代码的难度。
种种事先准备，可能确实是先见之明，也可能只是徒增麻烦。

> 我们能肯定地假设永远不会有超过256个敌人吗？好极了，我们可以将ID打包成一个单字节。在这里我们只会在一个具体类型上调用方法吗？好，我们就静态调度或者对它内联。所有的实体都是同一个类吗？太好了，我们可以将它们做成一个很棒的连续排列（第17章）。
> 这并不意味着它的灵活性很差！它可以让我们**快速**地进行游戏更新，开发速度是让游戏变得有趣的关键性因素。

游戏开发注重速度，很多时候写代码都**不需要考虑太多**，能实现功能就行。
这也是我工作几个月时间的体会——其他老程序员都对我写的代码的可扩展性不屑一顾，叫我只需要按照游戏功能的逻辑，写得越**简单**越好。

> 编写架构良好的代码需要仔细的思考，这是需要时间的。更多的是，在项目的生命周期内**维护一个良好的架构需要很大的努力**。你必须把你的代码库看作一个好的露营者在寻找营地一样：总是试着寻找比眼下更好的扎营点。
> 当你准备要长期和那份代码打交道时，这样是好的。但是，就像我之前提到的，游戏设计需要大量的试验和探索，特别是在早期，编写一些你知道迟早要扔掉的代码是很稀松平常的。

> 原型（把那些仅仅在功能上满足一个设计问题的代码融合在一起）是一个完全正确的编程实践。然而，特别提醒下，如果你编写一次性的代码，那么**你必须要确保能将之扔掉**。

要确保这些使用一次性代码的人们明白这种一次性代码看起来**能够运行**，但是它却**不可维护，必须被重写**。
可怕的是有些游戏公司的一次性代码堆积如山，看得我头皮发麻...

> 开发中我们有几个因素需要考虑。
> 1．我们想获得一个良好的架构，这样在项目的生命周期中便会更容易理解代码。
> 2．我们希望获得快速的运行时性能。
> 3．我们希望快速完成今天的功能。
> > 我认为一个有趣的地方是**这些都是关于某种速度**：我们的长期开发速度，游戏的执行速度，以及我们短期内的开发速度。
> 
> 这些目标至少部分是相冲突的。
> 1．好的架构从长远来看，改进了生产力，但维护一个良好的架构就意味着每一个变化都需要更多的努力来保持代码的干净。
> 2．最快编写的代码实现却很少是运行最快的。相反，优化需要消耗工程时间。一旦完成，也会使代码库僵化：高度优化过的代码缺乏灵活性，很难改变。
> 3．完成今日的工作并担心明天的一切总伴随着压力。但是，如果我们尽可能快的完成功能，我们的代码库就会充满了补丁、bug和不一致的混乱，会一点点地消磨掉我们未来的生产力。
> **这里没有简单的答案，只有权衡。**从我收到的电子邮件中，看得出来，这让很多人头疼。特别是对于想做一个游戏的新手们来说，听到这样说挺恐吓人的，“**没有正确答案，只是错误口味不同**”。

> 最近，我觉得如果有任何方法来缓解这些限制，那便是简单性了。在今天我所写的代码中，我非常努力地尝试着编写**最干净、最直接**的函数来解决问题。这种代码在你阅读之后，就会明白它究竟做了什么，并且不敢想象还有其他可能的解决方案。

这里说的简单性，貌似就是“可读性”。而且尽量不与别的功能耦合。

（本篇总结：）
> 1．抽象和解耦能够使得你的程序开发变得更快和更简单。但不要浪费时间来做这件事，除非你确信存在问题的代码需要这种灵活性。
> 2．在你的开发周期中要对性能进行思考和设计，但是要推迟那些降低灵活性的、底层的、详尽的优化，能晚则晚。
> 3．尽快地探索你的游戏的设计空间，但是不要走得太快留下一个烂摊子给自己。毕竟你将不得不面对它。
> 4．如果你将要删除代码，那么不要浪费时间将它整理得很整洁。摇滚明星把酒店房间弄得很乱是因为他们知道第二天就要结账走人。
> 5．但是，最重要的是，若要做一些有趣的玩意，那就乐在其中地做吧。
> > 相信我，在游戏发布前的两个月并不是你开始担心“游戏的FPS只有1帧”问题的时候。

对于游戏程序开发的总结很到位。
看到最后一句我笑了。

## 第2篇 再探设计模式

享元模式、观察者模式、单例模式、状态模式，这几章略过。

### 第2章 命令模式

> 命令就是一个对象化（实例化）的方法调用（A command is a reified method call）。

> 命令就是面向对象化的回调（Commands are an object-oriented replacement forcallbacks）。

> 反射是一个对象化的类型系统。

> 一些代码（输入处理或者AI）生成命令并将它们放置于命令流中，一些代码（发送者或者角色自身）执行命令并且调用它们。
> 通过中间的队列，我们将生产者端和消费者端解耦。

> 如果一个命令对象可以做（do）一些事情，那么就应该可以很轻松地撤销（undo）它们。

> 重做在游戏中并不常见，但**回放**却很常见。一个很简单的实现方法就是记录每一帧的游戏状态以便能够回放，但是这样会使用大量的内存。

“忍者必须死3”一场比赛的回放只有差不多几十kB大小……估计是记录了玩家的操作命令队列，而不是游戏状态队列。

### 第5章 原型模式

> 每一个怪物类只要包含孵化函数指针即可。

`Monster* (*SpawnCallback)();`定义了一个“返回值类型是Monster*、无参数的函数”的指针。

> 前面两种解决方案都强调我们需要定义一个类型参数化的生成器类。在C++里面，Class并不是头等公民。如果你使用像Javascript、Python和Ruby这样的把Class当作是头等公民的动态语言时，Class可以当作函数参数进行传递，那么你会得到更优雅的解决方案。

> 今天的大部分游戏，代码仅仅是一个驱动游戏的引擎，游戏的玩法被全部定义在数据中。
> 这样非常好，但是**简单地把内容都放到数据文件里面并不能解决大项目难于组织的问题**。而且，还有可能把问题搞得更复杂。我们使用编程语言的原因是因为它们可以管理复杂性。
> 为了不在10个地方去复制和粘贴代码，我们把它们封装成一个函数然后通过函数名来调用。为了不在多个类里复制粘贴代码，我们可以把它们放到一个单独的类里面，然后从它继承或者组合。
> 当你的游戏数据到达一定规模的时候，你会开始想要一些类似的特性。**数据建模**是一个很深的主题，这里我不会详细展开。但是，我希望可以抛砖引玉，让你可以在自己的游戏里面：使用原型和委托来重用数据。

“数据驱动”把业务逻辑和控制逻辑分离，cocos creator的设计理念就是数据驱动。这里说到了数据规模过大的问题和解决方向——数据建模。

## 第3篇 序列型模式

第10章更新方法模式略过。

### 第8章 双缓冲

> 双缓冲模式所解决的核心问题就是**对状态同时进行修改与访问**的冲突。
> 造成此问题的原因通常有两个，我们已经通过上述图形示例描述了第一种情况——状态直接被另一个线程或中断的代码所直接访问。
> 而另一种情况同样很常见：进行状态修改的代码访问到了其正在修改的那个状态。这会在很多地方发生：尤其是实体的AI和物理部分，在它与其他实体进行交互时会发生这样的情况，双缓冲模式往往能在此情形下奏效。

第二种情况解决的是这样一个问题：对象在某帧中“更新的顺序”会对“它们的交互结果”产生影响，因为前一个对象更新时，后一个对象还没更新。但我们希望它们同时更新。

### 第9章 游戏循环

> 在每帧的开始，我们基于**实际流逝的时间**更新变量lag。这一变量表示了游戏时钟相对现实时间落后的差量。
> 接着我们使用一个内部循环来更新游戏，每次以**固定时长**进行，直到它追赶上现实时间。**一旦赶上现实时间，我们开始渲染**并进行下一次游戏循环。

保证了在核心逻辑更新时，每一帧的时间都是固定的。

## 第4篇 行为型模式

### 第11章 字节码

> 大部分广泛使用的编程语言没有基于解释器模式也正因于此。它太慢了，并且占用了大量的内存。

> 这个模式是GoF解释器模式的姊妹版。它们都会为你提供一种用数据来组合行为的方法。
> 事实上，你经常会将两个模式一起使用。你用来生成字节码的工具通常会有一个内部对象树来表达代码。这正是解释器模式能做的事情。
> 为了将它编译成字节码，你需要递归遍历整棵树，正如你在解释器模式中解析它那样。唯一的不同是你并不是直接执行一段代码而是将它们输出成字节码指令并在以后执行它们。

解释器模式和字节码模式，都是为了让数据来驱动行为。区别在于字节码模式 的数据 事先要转换为字节码。

### 第12章 子类沙盒

> “使用基类提供的操作集合来定义子类中的行为。”

> 当你发现你的设计里像本例一样充满大量子类的时候，这通常意味着使用数据驱动方法可能更适合。你需要尝试找到一种**使用数据来定义行为**的方法，而不是用大量的重复代码来定义不同的行为。

> 模板函数模式正好与本模式相反。在这两个模式中，你都使用**一系列操作原语**来实现一个函数。使用子类沙盒模式时，函数在继承类中，原语操作则在基类中。使用模板函数时，基类定义函数骨架，而原语操作被继承类实现。

子类沙盒模式，一步步“操作”的定义在父类，组合“操作”的“算法骨架”在子类；模板模式，“算法骨架”在父类，而算法中的某些“操作”（步骤）在子类中实现。

> 你可以将这个模式看作是在外观模式上的一个变种。外观模式将许多不同的系统隐藏在了一个简化的API之下。在子类沙盒模式中，基类对于子类来说充当着隐藏游戏引擎实现细节的角色。

外观模式就是门面模式，它把子系统的一组接口包装成高层接口，让子系统更易用。

### 第13章 类型对象

（前文用种族举了个应用案例..）
> 虚函数表就是我们的种族对象，指向虚函数表的指针就是怪物对其种族的引用。C++类是类型对象模式在C上的应用，由编译器自动处理。

## 第5篇 解耦型模式

组件模式、事件队列，这两章略过。

### 第16章 服务定位器

> 就好像让一百个陌生人知道你家的地址，而仅仅是因为需要他们投递信件。这不仅有些隐私问题，而且当你搬家时你必须告诉每个人你的新地址，这实在是太痛苦了。
> 这里有个更好的解决办法：电话簿。每一个想要联系我们的人能够通过查找名字来得到我们当前的地址。当我们搬家时，我们告诉电话公司，他们更新电话簿，这样每个人都能得到新的地址了。

前者指使用静态类或单例，后者是使用定位器。定位器（Locator）使用依赖注入，将一个服务的“是什么”（具体实现类型）和“在什么地方”（我们如何得到它的实例）与需要使用这个服务的代码解耦了。

（服务定位器模式要慎用...）
> 与其给需要使用的地方提供一个全局机制来访问一个对象，不如首先考虑将这个对象传递进去。这极其简单易用，而且将耦合变得直观。这可以满足绝大部分需求。
> 但是，有时手动地将一个对象传来传去显得毫无理由或者使得代码难以阅读。

感觉使用全局对象的优点就是易于阅读代码。有时候读代码，跟踪着一个环境参数穿越了10层函数，才找到源头，很蛋疼。

## 第6篇 优化型模式

> **数据局部性**向你介绍了现代计算机的存储层次以及如何利用它的优势。**脏标记模式**帮助你避免不必要的计算，而**对象池**帮助你避免不必要的内存分配。**空间分区**会加速虚拟世界和其中元素的空间布局。

### 第17章 数据局部性

> 对刚访问数据的邻近数据进行访问的术语叫做**访问局部性**（locality of reference）。

这里要有计算机组成原理的知识。这个模式利用了CPU的缓存机制来加快内存的访问速度。
利用的方法之一，就是多用连续存储的数据结构——数组。文中还介绍了包装数据、冷热分解的方法。

> 在C++中，使用接口则意味着要通过指针或引用来访问对象。而使用指针进行访问也就是要在内存里来回地跳转，这就会引发本设计模式在极力规避的**缓存未命中**现象。
> 为了做到缓存友好，你可能需要牺牲一些之前所做的抽象化。你越是在程序的数据局部性上下工夫，你就越要牺牲继承、接口以及这些手段所带来的好处。这里并没有高招，只有利弊权衡的挑战。而乐趣便在这里。

（前文举了粒子系统的案例..）
> 为所有的粒子执行if判断将会引发CPU的**分支预测失准**和**流水线停顿**。……这也是为什么你有时也会看到开发者们**在关键代码中避开控制流语句**的原因。

解决方法是对粒子的数据进行有序存储，使被激活的粒子连续排列在最前端。

### 第18章 脏标记模式

> 一组原始数据随时间变化。一组衍生数据经过一些代价昂贵的操作由这些数据确定。一个脏标记跟踪这个衍生数据是否和原始数据同步。它在原始数据改变时被设置。如果它被设置了，那么当需要衍生数据时，它们就会被重新计算并且标记被清除。否则就使用缓存的数据。

这个的主要作用是性能优化。从原始数据到衍生数据的计算代价太大时，可以通过标记和缓存来跳过一些衍生计算。

> 这种模式在游戏外的领域也是常见的，比如在Angular这种BS（browser-side）框架中。它利用脏标记来跟踪浏览器中有变动并需要提交到服务端的数据。

这个技术叫做VDOM（虚拟DOM），即用JavaScript模拟HTML页面的DOM（文档对象模型）结构。
浏览器进行DOM操作是非常昂贵的。因为修改DOM是浏览器开放给开发者的API，调用它就会触发浏览器的重绘机制。
VDOM在JS层对比DOM的变化，精细地修改内容，不修改的地方不去修改，可以提高浏览器重绘性能。

### 第19章 对象池

> 对于内存管理器而言，我们仅分配一大块内存直到游戏结束才释放它，对于内存池的使用者而言，我们可以按照自己的意愿来分配和释放对象。

目的是避免内存碎片和提升内存分配的速度。

> 定义一个保持着可重用对象集合的对象池类。其中的每个对象支持对其“使用（in use）”状态的访问，以确定这一对象目前是否“存活（alive）”。在对象池初始化时，它预先创建整个对象的集合（通常为一块连续堆区域），并将它们都置为“未使用（not in use）”状态。

前段时间在项目里看到一个奇怪的数据结构`IDTable`，是一个静态数组，里面的元素只不过用来存储ID，却有3种状态。当时叫不出它的名字，现在终于知道叫“对象池”了……
那个`IDTable::Add`方法里做了比较耗时的操作，原来是为了保证数据的连续存储，反而能提升运行效率。

### 第20章 空间分区

> 对于一组对象而言，每一个对象在空间都有一个位置。将对象存储在一个根据对象的位置来组织的数据结构中，该数据结构可以让你高效地查询位于或靠近某处的对象。当对象的位置变化时，应更新该空间数据结构以便可以继续这样查找对象。

这个的目的是提高“查找地图上某个单位附近的其他单位”的效率。这个模式以空间换取速度，而且一旦单位的位置改变，处理起来很复杂。
排序以后可以使用二分查找，检索“所有单位的两两之间距离”的复杂度从O(n²)降到了O(nlogn)。书上还说用类似“鸽巢排序”的算法可以将复杂度降到O(n)……待研究。

最后作者列举了“游戏中最常见的一些空间分区结构”（当我看到这些就决定放弃使用这个模式了……）：

> 下一步你应该要去了解一些常见的结构。尽管它们的名字吓人，但却出奇的简单明了。
> 常见的有：网格[Grid（spatial_index）]、四叉树、二叉空间分割、k-dimensional树、层次包围盒。
> 每一个空间数据结构基本都是从一个现有已知的一维数据结构扩展到多维，了解它们的线性结构会帮助你判断它们是否适合于解决你的问题：
> 网格是一个连续的桶排序。
> 二叉空间分割，k-d树，以及层次包围盒都是二叉查找树。
> 四叉树和八叉树都是Trie树。