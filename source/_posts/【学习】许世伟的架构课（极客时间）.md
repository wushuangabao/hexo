---
title: 【学习】许世伟的架构课（极客时间）
tags:
  - 学习
  - 软件
categories:
  - 软件工程
toc: false
date: 2019-06-17 22:27:03
---

## 开篇词 | 怎样成长为优秀的软件架构师？

许世伟2000年开始工作，曾是WPS首席架构师，在盛大做过，2011年创立了七牛云，现在是一名创业者、CEO。

<!--more-->

把程序员类比成建筑师，按能力来分有三个层次：**搬砖师、工程师、架构师**。

软件诞生后，需要花费大量代价维护。程序员更多的时间是用来维护代码。

**代码质量的评判有这样一些基本维度：可阅读性、可扩展性/可维护性、可测试性、可复用性**。

阅读和维护软件工程师写的代码会有一种赏心悦目的感觉。

软件工程是一项非常复杂的系统工程，它需要依赖一个能**掌控全局**的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。

掌控全局的前提是：在自己心中去重新构筑出整个世界。

**课程脉络**：首先，我们通过还原信息世界的构建过程，剥离出了整个信息世界的核心骨架，这也是最真实、最宏大的架构实践案例。其次，我们结合这个宏大的架构实践来谈架构思维，避免因对架构思维的阐述过于理论化而让人难以理解。

## 01架构设计的宏观视角

课程内容从基础架构讲起，慢慢过渡到业务架构。

### 应用程序的基础架构

电脑的构成：中央处理器+存储+一系列的输入输出设备

如此简单，电脑却能完成复杂和多样化的功能。主要依赖两点：

1. 可编程性。虽然CPU指令是一个有限的指令集，但是CPI执行的指令序列并不固定，而是依赖存储中的数据（程序）来决定。
2. 开放设计的外部设备支持。CPU并不理解外部设备具有什么样的能力，只和它们交换数据。

CPU是一个非常简洁的模型，它只读写数据，对数据进行计算。

- 机器指令编写软件太累——编程语言+编译器出现
- 多个软件写数据、传指令冲突怎么办——操作系统出现，解决软件治理和基础编程接口问题

### 完整的程序架构是怎么样的？

业务架构（应用架构），只须关心应用程序的本身的**业务问题如何构建**。

不同的业务架构之间，不止遵循相同的**架构原则**，还可以遵循相同的的**设计范式**。例如，在用户交互领域有著名的 MVC 框架（如 JavaScript 语言的 Angular，PHP 语言的 Zend，Python 语言的 Django），在游戏开发领域有各种游戏引擎（如 JavaScript 语言的 Phaser，C# 语言的 Unity3D），等等。

对于一个服务端应用程序来说，其完整的架构体系大体如下图：

![服务端架构图](http://m.qpic.cn/psb?/V11Tp57c2B9kPO/0MSWJ4nCfsEX6w4ta.FIUFxYPeQReg5sC5dQlRDsh5s!/b/dL4AAAAAAAAA&bo=GwU.AwAAAAARBxM!&rf=viewer_4)

客户端应用程序和服务端有很大差别，首先面临多样性的挑战（操作系统、设备种类）。

浏览器是第一个想要消除客户端的多样性，跨平台提供统一接口的，地位非常特殊，可以看做是操作系统之上的操作系统。对于一个客户端应用程序来说，其完整的架构体系大体如下：

![客户端架构图](http://m.qpic.cn/psb?/V11Tp57c2B9kPO/.wKTGDkr5hAa2IZp6DWpX2.KhtlK0XMdLmF8mHE2ovE!/b/dMAAAAAAAAAA&bo=vQV2AwAAAAARB*0!&rf=viewer_4)

## 02解剖冯·诺依曼体系结构

### 解剖架构的关键点

当我们设计或分析架构设计中涉及的每一个零部件时，我们关心哪些问题？

1. 需求。这个零部件的作用是什么？它被用来做哪些事？不会被用来做哪些事？为什么不会？
2. 规格。这个零部件的接口是什么样的？它如何与其他零件连接在一起？

**解决一切可“计算”问题，这是冯·诺依曼的需求**。

### 冯·诺依曼体系的规格

为了实现需求，冯·诺依曼引入了三类基础零部件：
- 中央处理器，负责程序（指令序列）的执行；
- 存储（中央处理器内置支持的存储）；
- 输入输出设备。

**为什么这么简洁的规格设计，可以解决这么复杂的需求**？

### 需求是怎么被满足的？

一方面，**需求的变化点**在于，要解决的问题是五花八门包罗万象的。如何以某种稳定但可扩展的架构来支持这样的变化？而另一方面，**需求的稳定之处**在于，电脑的核心能力是固定的。

电脑的核心能力是“计算”。就是对一个数据（输入）进行变换，变为另一个数据（输出）。在数学中我们把它叫做“函数”。

> y = F(x)

这里x、y是数据。无论它们的逻辑含义为何，物理上都可以用一段连续的字节内容来表达。那么x、y物理上在哪里？得有一个“存储”用来存放操作的数据。

而函数 F，对于架构师来说也是未知的。怎样设计一种架构让用户可以表达任意复杂度的函数（计算）？逻辑上，无论多复杂的自定义函数，都可以用一组指令序列来表达。这些指令包括：
- 执行最小计算单元，如数字的加减乘除（也就是内置函数）；
- 执行顺序，包括条件分支、循环；
- 执行其他自定义的函数（子函数）。

F 物理上在哪里？以指令序列（程序）形式存放在存储里。**存储不仅存放数据，也存放“计算”本身**。

有了负责计算的中央处理器，以及存储，就可以进行任意复杂的“计算”了。但是它无法和现实世界发生交互，即输入和输出。

对于电脑来说，输入输出的需求就更多了。但不管是什么样交互用途的设备，我们要做的只是**定义好统一的数据交换协议**。

除了纯正的“计算”能力外，中央处理器还要有“数据交换”能力（或者叫 IO 能力）。

最终，电脑可以被看做由 “**中央处理器 + 存储 + 一系列的输入输出设备**” 构成。

（以上内容仅仅是说明，具体细节参考学科：计算机组成原理、汇编语言等）

### 架构思维总结

架构的第一步是需求分析。需求分析的关键是**抓住需求的稳定点和变化点**。架构目标是剥离变化的部分，将其抽象到接口层去实现（做成开放性设计），让系统的核心价值（功能）保持稳定。

对于“电脑”这个产品而言，需求的稳定点是电脑的“计算”能力。需求的变化点，一是用户“计算”需求的多样性，二是用户交互方式的多样性。

电脑的“计算”能力，最终体现为中央处理器的指令集，这是需求相对稳定的部分。

用户“计算”需求的多样性，最终是通过在存储中的指令序列实现。计算机加电启动后，中央处理器并不是按自己固有的“计算”过程进行，而是从一个固定的存储地址加载指令序列执行。

扩展阅读：
- [电脑结构和CPU、内存、硬盘三者之间的关系](https://www.cnblogs.com/resn/p/5766142.html)
- [计算机发展史](https://www.cnblogs.com/resn/p/5731067.html)

## 03汇编语言的诞生

对于现代计算机来说，虽然 CPU 指令是一个很有限的指令集，但是 CPU 执行的指令序列（或者叫“程序”）并不是固定的，它依赖于保存在存储中的数据，由软件工程师（或者叫“程序员”）编写的软件决定。

在第一门面向程序员的编程语言出现前，人们只能通过理解 CPU 指令的二进制表示，将程序以二进制数据方式刻录到存储（比如 ROM 或硬盘）上。

这个时候软件和硬件的边界还非常模糊，并不存在所谓软件工程师（或者叫“程序员”）这样的职业。写程序也并不是一个纯软件的行为，把程序刻录到存储上往往还涉及了硬件的电气操作。

为了解决编程效率的问题，汇编语言（和解释它的编译器）诞生了。汇编语言的编译器将汇编语言写的程序编译成为 CPU 指令序列，并将其保存到外置的存储设备（比如硬盘）上。

汇编语言的出现，让写程序（编程）成为一个纯软件行为（出现“程序员”这个分工的标志），人们可以专注于程序逻辑的表达、反复修改程序，然后通过汇编编译器将其翻译成机器语言，并写入到外置的存储设备（比如硬盘）。

这一步所解放的生产力是惊人的。程序的源代码可以进行**迭代演进**了。软件程序不断被传承，并最终演进出今天的信息世界。

## 04编程语言的进化

软件是活的书籍，是人类知识传承能力的一次伟大进化。它比书籍更好：
- 表达方式多样
- 对技术的现场还原

### 编程范式的进化

- 过程式。最核心的概念是结构体（自定义的类型）和过程（也叫函数）。
- 函数式。本质上是过程式编程的一种约束，核心主张是变量不可变、函数尽可能没有副作用。学习成本高，代表语言有 Haskell, Erlang。
- 面向对象。在过程式的基础上，主张尽可能把方法（即过程）归纳到合适的对象中。

面向对象的核心思想是引入契约，基于对象这个概念对代码的使用界面进行抽象和封装。有两个显著优点：
- 清晰的使用界面。数据结构和过程的关系不再松散。
- 信息的**封装**。提高了可复用性，通过接口优雅地实现**多态**的能力。

对于**继承**，褒贬不一。本来复合对象的唯一构造方法是组合，现在多了一个选择，令人纠结。

Go 语言给出了答案：放弃继承，全面强化**组合**能力。

一些语言明确主张自己是多范式的，比如 C++。

Go 保留了每一种编程范式的精华部分，但是 Go 官方认为 Go 是一门**面向连接**的语言。体现了朴素的组合思想。

Go 语言设计的方方面面都需要契约，直接消灭了那些代码写法容易产生区别的地方，让大家专注于意图的表达。

### 其他方面的进化

除了编程范式，编程语言的工程能力也越来越完善，体现在：
- 包（package），即代码的发布单元。
- 版本（version），即包的依赖管理。
- 文档生成（doc）。
- 单元测试（test）。

从语言的执行器行为看，出现了这样三种分类的语言：
- 编译的目标文件为可执行程序。典型代表有 Fortran, C/C++, Go 等。
- 生成跨平台的虚拟机字节码，有独立的执行器（虚拟机）执行字节码。典型代表 Java, Erlang。
- 直接解释执行。典型代表是 JavaScript。当然现在纯解释执行的语言已经不多了，大多数直接执行的语言内部还是会有虚拟机的。

### 语言对架构的影响

之前的架构图中，三种不同的颜色表示不同层次的依赖。

无论是服务端还是客户端，可以同意将其架构图简化为：
- 业务架构——源代码层次的依赖，程序本身的组成部分
- 应用程序框架及各类基础库——库层次的依赖，程序本身的组成部分，但与业务无关
- 基础软件（操作系统、编程语言及各种中间件）——软件层次的依赖，程序工作的生态环境
- 冯·诺依曼体系架构——硬件层次的依赖，程序工作的物理基础

从软件的业务架构来说，怎么拆分模块（确定业务边界）是业务需求本身决定的，与编程语言无关。但是在**描述每个模块的规格**时，采用的规格描述语言会面临如下两种选择：
- 选择某种语言无关的接口表示；
- 选择团队开发时采用的编程语言来描述接口。

两者无本质差异，但语言的选择在实践中对业务架构的决策的影响仍然及其关键。原因：
- 开发效率有差异。抛开语言本身的开发效率不谈，不同语言会有不同的社区资源，还有企业发展形成的框架和基础库；
- 后期维护。语言有生命周期，会走向衰弱。

## 06操作系统进场

操作系统就是软件之间的协调方，制定规则并约束这些软件的行为。

操作系统的执行权，是计算机主板 ROM 上的启动程序（BIOS）交给它的。

### 操作系统的需求演进

编程语言出现后，软件生产效率得到了大幅度提升。软件越来越多，多个软件如何和谐共处？这就诞生了**软件治理**的需求：
- 多个软件如何同时运行（多任务的需求）？
- 多个软件如何共同使用计算机上的存储空间（内存管理、文件系统的需求）？
- 多个软件如何共同使用同一个外部设备（设备管理的需求）？
- 多个软件如何相互通讯，如何进行数据交换（进程间通讯、共享内存的需求）？
- 病毒、恶意软件如何治理（安全管理的需求）？

**客户价值维度**

首先要解决的是**软件治理**问题。大体分为以下6个子系统：进程管理、存储管理、输入设备管理、输出设备管理、网络管理、安全管理。

其次解决的是**基础编程接口**问题。这些编程接口一方面简化了软件开发，另一方面提供了多软件共同运行的环境，实现了软件治理。

**商业价值维度**

操作系统是**基础的刚需软件**，计算机离不开操作系统。

操作系统也是**核心的流量入口**。占领了操作系统，就占有了用户。

无论是本地操作系统 iOS 和 Android，还是 Web 操作系统（浏览器）如微信小程序，都**实现了“帐号 - 支付 - 应用市场”这样的商业闭环**。这类操作系统，我们不妨把它叫做现代操作系统。

### 操作系统的边界

架构的第一步是需求分析。在架构设计过程中，需求分析至少应该花费三分之一的精力。

当我们说要做一个操作系统的时候，我们的自己对这句话的理解也是非常模糊的。尤其当我们正准备做的事情是一个新生事物的时候。

架构也关乎用户需求，我们不止要知道用户当前的需求，还要预测需求未来可能的变化，预判什么会发生、而什么不一定会发生。

我是否能预料到，有一天支付（Pay）系统会成为操作系统的核心子系统？如果不能，那怎么才能做到？

操作系统的边界到底在哪里？

看清楚这样三个角色的关系：
- 硬件（个人计算机、手机或其他）
- 操作系统
- 浏览器




